
#ifndef AtmoRender
#define AtmoRender

static const float PI = 3.14159265359;

static const int NUM_DIR_LIGHTS = 1;

// reference planet data
static const float reference_planet_radius = 6371000.0;
static const float reference_atmosphere_radius = 100000.0;
static const float reference_total_radius = reference_planet_radius + reference_atmosphere_radius;
static const float reference_ratio = reference_planet_radius / reference_atmosphere_radius;

// scattering coefficents
//static const float3 BETA_RAYLEIGH = float3(0.0000055, 0.000013, 0.0000224);                   /* rayleigh, affects the color of the sky */
//static const float  BETA_MIE =  0.000021;                                                      /* mie, affects the color of the blob around the sun */
//static const float3 BETA_ABSORPTION  = float3(0.0000204, 0.0000497, 0.00000195);               /* what color gets absorbed by the atmosphere (Due to things like ozone) */
//static const float3 BETA_AMBIENT = float3(0.000000,0.0000000,0.0000000);                      // the amount of scattering that always occurs, cna help make the back side of the atmosphere a bit brighter
static const float g = 0.70;                                                                  /* mie scattering direction, or how big the blob around the sun is */

// scattering coefficents
// rayliehg is wavelength dependent affects r g b differently, mie is wavelength indpenedent ( effect all colors equally)
static const float3 SIGMA_RAYLEIGH_S = float3(0.000005802, 0.000013558, 0.0000331);
static const float  SIGMA_MIE_S = 0.000003996;
static const float  SIGMA_OZONE_S = 0;

// Absorption coefficents
static const float  SIGMA_RAYLEIGH_A = 0;
static const float  SIGMA_MIE_A = 0.0000044;
static const float3 SIGMA_OZONE_A = float3(0.00000065, 0.000001881, 0.000000085); 

// and the heights (how far to go up before the scattering has no effect)
static const float HEIGHT_RAY = 8000.0;                                                       /* rayleigh height */
static const float HEIGHT_MIE = 1200.0;                                                       /* mie height */
static const float HEIGHT_ABSORPTION = 30000;                                                 /* at what height the absorption is at it's maximum */
static const float ABSORPTION_FALLOFF = 4000;                                                 /* how much the absorption decreases the further away it gets from the maximum height */


// Struct Decloration
//-----------------------------------------------------------------------------------------------------------------
struct DirectionalLight
{
    float3 direction;
    float intensity;
};

struct PlanetData
{
    float3 planet_center;
    float planet_radius;
    float atmosphere_radius;
    float total_radius;
    float scale_ratio;
    float planet_scale;
    float atmosphere_scale;
};

DirectionalLight CreateDirectionalLight(float3 dir, float inten)
{
    DirectionalLight dl;
    float3 normalized_light_dir = normalize(dir);
    dl.direction = normalized_light_dir;
    dl.intensity = inten;
    return dl;
}

PlanetData CreatePlanetData(float3 planet_center, float planet_radius, float atmosphere_radius)
{
    PlanetData planet_data;
    planet_data.planet_center = planet_center;
    planet_data.planet_radius = planet_radius;
    planet_data.atmosphere_radius = atmosphere_radius - planet_radius;
    planet_data.total_radius =  planet_radius + planet_data.atmosphere_radius;



    planet_data.scale_ratio = planet_radius / planet_data.atmosphere_radius;
    planet_data.planet_scale = reference_planet_radius / planet_radius;
    planet_data.atmosphere_scale = planet_data.scale_ratio / reference_ratio;
    return planet_data;
}

// Helper functions
//-----------------------------------------------------------------------------------------------------------------

float Magnitude(float3 vector_3) 
{
    return sqrt(dot(vector_3, vector_3));
}

bool RayIntersectsPoint(float3 ray_start, float3 ray_dir, float3 world_pos)
{
    // Calculate the vector from the ray start to the world position.
    float3 rayToPosition = world_pos - ray_start;

    // Calculate the distance along the ray direction to the intersection point.
    float t = dot(rayToPosition, ray_dir);

    // Check if the intersection point is in front of the ray (t >= 0).
    if (t >= 0.0)
    {
        // Calculate the point on the ray closest to the world position.
        float3 closestPointOnRay = ray_start + t * ray_dir;

        // Check if the closest point on the ray is very close to the world position.
        // You may want to adjust this epsilon value based on your needs.
        float epsilon = 0.001; // A small value to account for floating-point errors.
        return length(closestPointOnRay -  world_pos) < epsilon;
    }

    // If t < 0, the intersection point is behind the ray.
    return false;
}

float2 RaySphereIntersect(float3 start, float3 dir, float radius, float3 sphere_center) 
{
    // float3 start: starting position of the ray
    // float3 dir: ray direction
    // float radius: radius of the planet. 

    // ray-sphere intersection that assumes
    // the sphere is centered at the origin.
    // No intersection when result.x > result.y

    // Translate the ray and sphere to be relative to the sphere's center
    float3 ray_origin_relative_to_center = start - sphere_center;

    // Ray-sphere intersection using quadratic equatrion
    float a = dot(dir, dir);
    float b = 2.0 * dot(dir, ray_origin_relative_to_center);
    float c = dot(ray_origin_relative_to_center, ray_origin_relative_to_center) - (radius * radius);
    float d = (b*b) - 4.0*a*c;

    if (d < 0.0) 
        return float2(100000,-100000);

    // first and second intersection point along the ray's path
    float first_intersection = (-b - sqrt(d))/(2.0*a);
    float second_intersection = (-b + sqrt(d))/(2.0*a);

    return float2( first_intersection, second_intersection);
}

//-----------------------------------------------------------------------------------------------------------------

//How much light makes it from xa (ray_origin) to xb (intersecxtion_point) without being absorbed or scattered?"
float3 MediumTransmittance(float3 ray_origin, float3 intersection_point, int STEP_COUNT, float4 SCALED_HEIGHTS, PlanetData planet_data, float ray_pos_offset)
{
    // Calculate the direction of the ray
    float3 ray_dir = normalize(intersection_point - ray_origin);

    // Calculate the step size based on the length of the ray segment
    float actual_step_size = length(intersection_point - ray_origin) / float(STEP_COUNT);
    float virtual_step_size = actual_step_size * planet_data.planet_scale;
    float ray_pos = ray_pos_offset + actual_step_size * 0.5;

    float3 optical_depth = 0;

    // Calculate the extiction coefficent. Am using precomputed values for scattering and absoprtion coefficents so no need to worry about sigmat(x)
    float3 sigma_scattering = SIGMA_RAYLEIGH_S + SIGMA_MIE_S + SIGMA_OZONE_S;
    float3 sigma_absorption = SIGMA_RAYLEIGH_A + SIGMA_MIE_A + SIGMA_OZONE_A;
    float3 sigma_t = sigma_scattering + sigma_absorption;    
    
    for (int j = 0; j < STEP_COUNT; j++)
    {   
        // current position along the ray
        float3 current_sample_pos = ray_origin + ray_dir * ray_pos;

        // Calculate the height of the position
        float current_height = length(current_sample_pos) - planet_data.planet_radius;

        // Calculate the transmittance (density) using the exponential function
        // transmittance = e^(-density) where density = (current_height / scaled_heights)
        // we are assuming that the change in density is just a function of height
        float3 density = float3(exp(-current_height / SCALED_HEIGHTS.xy), 0.0);
        float denom = (SCALED_HEIGHTS.z - current_height) / SCALED_HEIGHTS.w;
        density.z = (1.0 / (denom * denom + 1.0)) * density.x;

        // multiply the density by the step size
        density *= virtual_step_size;

        // Multiply by the extinction coefficient
        density *= sigma_t;

        // add the density to the total optical depth
        optical_depth += density;

        // increment the position along the ray
        ray_pos += actual_step_size;
    }


    float3 transmittance = exp(-optical_depth);

    /* transmittance.x corresponds to the Rayleigh extinction coefficient's transmittance.
    transmittance.y corresponds to the Mie extinction coefficient's transmittance.
    transmittance.z corresponds to the ozone extinction coefficient's transmittance.*/

    return transmittance;
}




// S(x,li)
float3 ShadowFactor(float3 current_sample_pos, float3 light_dir, PlanetData planet_data, float3 ground_intersection, int LIGHT_STEP_COUNT, float4 SCALED_HEIGHTS)
{
    // Calculate shadowing from the planet
    
    // Determine whether the light ray intersects the planet. If it does return 0, if the ray reaches the edge of the atmosphere return 1.
    float shadow_vis = 1;

    // To determine whether the light ray intersects the grond, while we are ray marching the light ray we have
    // to check whether the current light sample position is further from the camera than the value stored in the depth buffer
    // we already are iterating over the light ray 

    // Calculate the distance to the atmosphere edge from the current sample position
    float a = dot(light_dir, light_dir);
    float b = 2.0 * dot(light_dir, current_sample_pos);
    float c = dot(current_sample_pos, current_sample_pos) - (planet_data.total_radius * planet_data.total_radius);
    float d = (b * b) - 4.0 * a * c;

    // no early stopping, this one should always be inside the atmosphere
    float dist_to_atmo_edge = (-b + sqrt(d)) / (2.0 * a);

    // Calculate shadowing from the atmosphere from current sample pos to the light (light ray march)
    float3 shadow_t = MediumTransmittance(current_sample_pos, current_sample_pos + dist_to_atmo_edge * light_dir, LIGHT_STEP_COUNT, SCALED_HEIGHTS, planet_data, 0);

    return shadow_t * shadow_vis;
}


float3 ComputePhase(float3 ray_direction, float3 light_dir, bool allow_mie)
{
    // Calculate the Rayleigh and Mie phases.
    // This is the color that will be scattered for this ray
    // mu, mumu and gg are used quite a lot in the calculation, so to speed it up, precalculate them
    float mu = dot(ray_direction, light_dir);
    float mumu = mu * mu;
    float gg = g * g;
    float phase_rayleigh = 3.0 / (50.2654824574) * (1.0 + mumu);
    float phase_mie = allow_mie ? 3.0 / (25.1327412287) * ((1.0) - gg) * (mumu + 1.0) / (pow(max(0.0, (1.0 + gg - 2.0 * mu * g)), 1.5) * (2.0 + gg)) : 0.0;

    return float3(phase_rayleigh, phase_mie, 1);
}

float ComputeIlluminance(DirectionalLight dl, float3 ray_direction)
{   
    // illuminance (considering directional light sources) Ei
    // Angle (θ): The angle between the direction of the light (given by the direction vector 
    // of the directional light) and the normal vector of the surface at the point of interest.
    // Distance (r): The distance from the light source to the point on the surface.
    
    // the normal between the view ray direction and the light direction
    //float normal = 
    //float theta = acos(dot(DIR_LIGHTS[i].direction, normal));
    //float E = DIR_LIGHTS[i].intensity * cos(theta) / (r^2);

    float E = dl.intensity / PI;

    return E;
}

// Lscat(c,x,v)
float3 CalculateInScattering(float3 camera_pos, float3 current_sample_pos, float3 dir_to_viewer, DirectionalLight DIR_LIGHTS[NUM_DIR_LIGHTS], bool allow_mie, PlanetData planet_data, float3 intersection_point, int PRIMARY_STEP_COUNT, int LIGHT_STEP_COUNT, float4 SCALED_HEIGHTS, float atmosphere_intersect, float3 scene_color, float3 ray_start)
{

    // luminance is the intensity of the emitted light from a surface per unit area in a particular direction. 
    float3 luminance = 0;

    for(int i = 0; i < NUM_DIR_LIGHTS; i++)
    {   
        // It is important that the ray_origin passed to the medium transmittance function 
        // starts at the edge of the atmophere if the camera is not within the atmosphere

        
        // MEDIUM TRANSMITTANCE (from viewer to current sample pos while ray marching (primary view ray marching)):
        // transmittance.x = Rayleigh extinction coefficient's transmittance (viewer to current sample point)
        // transmittance.y = Mie      extinction coefficient's transmittance (viewer to current sample point)
        // transmittance.z = Ozone    extinction coefficient's transmittance (viewer to current sample point)
        float3 transmittance = MediumTransmittance(camera_pos, current_sample_pos, PRIMARY_STEP_COUNT, SCALED_HEIGHTS, planet_data, 0);

        //if((Magnitude(transmittance) == 0.0))
            //return float3(1,1,1);

        // SHADOW_FACTOR (needed for volumetric shadows):
        // shadow_factor.x = Rayleigh extinction coefficient's transmittance (current sample point to light) * visibility
        // shadow_factor.y = Mie      extinction coefficient's transmittance (current sample point to light) * visibility
        // shadow_factor.z = Ozone    extinction coefficient's transmittance (current sample point to light) * visibility
        float3 shadow_factor = ShadowFactor(current_sample_pos, DIR_LIGHTS[i].direction, planet_data, intersection_point, LIGHT_STEP_COUNT, SCALED_HEIGHTS);
        
        // PHASE FUNCTION:
        // phase.x = Rayleigh phase
        // phase.y = Mie phase
        // phase.z = Ozone phase = 1
        float3 phase = ComputePhase(-dir_to_viewer, DIR_LIGHTS[i].direction, allow_mie);

        // illuminace Ei
        float illuminance = ComputeIlluminance(DIR_LIGHTS[i], dir_to_viewer);
        //illuminance *= scene_color;
        
        //luminance += transmittance * shadow_factor * phase * illuminance;
        luminance += shadow_factor;
        //luminance += transmittance * phase * illuminance;
    }


    // Scattering Coefficent at current sample position.
    float3 sigma_scattering = SIGMA_RAYLEIGH_S + SIGMA_MIE_S + SIGMA_OZONE_S;
    //float3 attenuation = exp(r);
    //luminance *= sigma_scattering;


    return luminance;
}


float3 RenderScene(float3 ray_origin, float3 ray_direction, float3 scene_color, float max_dist, PlanetData planet_data, int PRIMARY_STEP_COUNT, int LIGHT_STEP_COUNT, float4 world_pos_depth, DirectionalLight DIR_LIGHTS[NUM_DIR_LIGHTS], float3 cuttoff_threshold)
{   

    // Adjust absorption heights based on planet / atmosphere scale
    //-----------------------------------------------------------------------------------------------------------------

    // Scale the heights (how far to go up before the scattering has no effect)
    float SCALED_HEIGHT_RAY = HEIGHT_RAY / (planet_data.planet_scale * planet_data.atmosphere_scale);
    float SCALED_HEIGHT_MIE = HEIGHT_MIE / (planet_data.planet_scale * planet_data.atmosphere_scale);
    float SCALED_HEIGHT_ABSORPTION = HEIGHT_ABSORPTION * (planet_data.planet_scale * planet_data.atmosphere_scale);
    float SCALED_ABSORPTION_FALLOFF = ABSORPTION_FALLOFF / (planet_data.planet_scale * planet_data.atmosphere_scale);
    float4 SCALED_HEIGHTS = float4(SCALED_HEIGHT_RAY, SCALED_HEIGHT_MIE, SCALED_HEIGHT_ABSORPTION, SCALED_ABSORPTION_FALLOFF);


    // Calculate p, the ground intersection position
    //-----------------------------------------------------------------------------------------------------------------
    ray_origin -= planet_data.planet_center;

    // calculate the start and end position of the ray, as a distance along the ray
    // we do this with a ray sphere intersect
    float a = dot(ray_direction, ray_direction);
    float b = 2.0 * dot(ray_direction, ray_origin);
    float c = dot(ray_origin, ray_origin) - (planet_data.total_radius * planet_data.total_radius);
    float d = (b * b) - 4.0 * a * c;

    // Early out if ray doesn't intersect atmosphere.
    if (d < 0.0) return scene_color;
    
    float2 ray_length = 0;

    // NOTE: THIS SECTION OF CODE ASSUMES THAT THE WORLD POSITION IS STORED IN THE XYZ CHANNELS OF THE GROUND_INTERSECTION, AND THE DEPTH IN THE ALPHA
    
    /*
    // calculate the ray length
    if(Magnitude(world_pos_depth.xyz != 0))
    {
        // the first intersection point should always be the atmosphere, if it hits the atmosphere.
        // if the primary ray does hit ground, then that will be the second intersection point.
        // As the magnitude of a vector is always non-negative no need to take the max
        ray_length = float2( max((-b - sqrt(d)) / (2.0 * a), 0.0), Magnitude(world_pos_depth.xyz-ray_origin));
        max_dist = Magnitude(world_pos_depth.xyz-ray_origin);
    }
    else
    {
        ray_length = float2( max((-b - sqrt(d)) / (2.0 * a), 0.0), min((-b + sqrt(d)) / (2.0 * a), max_dist));
        // if the ray did not hit the atmosphere, return the scene color
        if(ray_length.x > ray_length.y) return scene_color;
    }*/
       
    ray_length = float2( max((-b - sqrt(d)) / (2.0 * a), 0.0), min((-b + sqrt(d)) / (2.0 * a), max_dist));
    // if the ray did not hit the atmosphere, return the scene color
    if(ray_length.x > ray_length.y) return scene_color;
    
    // prevent the mie glow from appearing if there's an object in front of the camera
    bool allow_mie = max_dist > ray_length.y;

    // make sure the ray is no longer than allowed
    ray_length.y = min(ray_length.y, max_dist);
    ray_length.x = max(ray_length.x, 0.0);

    // Calculate the first intersection point along the ray. Intersection with the atmosphere.
    float3 intersection_point = ray_origin + ray_direction * ray_length.x;
    float3 end_point = ray_origin + ray_direction * ray_length.y;

    // Check if the absolute value of the x-coordinate of the intersection point is greater than some threshold.
    if (abs(intersection_point.x) > cuttoff_threshold.x || abs(intersection_point.z) > cuttoff_threshold.z || abs(intersection_point.y) >cuttoff_threshold.y) return scene_color; // Return black color.


    //-----------------------------------------------------------------------------------------------------------------
    // Ray march the primary ray
    //-----------------------------------------------------------------------------------------------------------------

    // get the step size of the ray
    float actual_step_size_p = (ray_length.y - ray_length.x) / float(PRIMARY_STEP_COUNT);
    float virtual_step_size_p = actual_step_size_p * planet_data.planet_scale;

    // next, set how far we are along the ray, so we can calculate the position of the sample
    // if the camera is outside the atmosphere, the ray should start at the edge of the atmosphere
    // if it's inside, it should start at the position of the camera
    // the min statement makes sure of that
    float ray_pos_p = ray_length.x + actual_step_size_p * 0.5;

    // these are the values we use to gather all the scattered light
    //float3 accumulated_rayleigh = 0;
    //float3 accumulated_mie = 0;

    float3 in_scatter_sum = float3(0,0,0);

    for(int i = 0; i < PRIMARY_STEP_COUNT; i++)
    {
        // calculate where we are along this ray
        float3 primary_sample_pos = ray_origin + ray_direction * ray_pos_p;

        //This integral accounts for the scattered light along the ray, essentially sums up all the contributions of scattered light along the path.
        // Start at the 
        in_scatter_sum += CalculateInScattering(  intersection_point, 
                                                    primary_sample_pos, 
                                                    ray_direction, 
                                                    DIR_LIGHTS, 
                                                    allow_mie, 
                                                    planet_data, 
                                                    world_pos_depth.xyz, 
                                                    PRIMARY_STEP_COUNT, 
                                                    LIGHT_STEP_COUNT,
                                                    SCALED_HEIGHTS,
                                                    ray_length.x,
                                                    scene_color,
                                                    intersection_point );
        
        //float3 in_scatter = float3(1,1,1);
        // increment the primary ray
        ray_pos_p += actual_step_size_p;
    }

    float3 luminance = in_scatter_sum;
    //float3 luminance = 1;
    // Medium Transmittance from the camera to the ground intersect position:
    float3 medium_transmittance = MediumTransmittance(intersection_point, end_point, PRIMARY_STEP_COUNT, SCALED_HEIGHTS, planet_data, 0);
    luminance *= 1.0;

    //float3 opacity = exp( -(BETA_MIE * optical_depth.y + BETA_RAYLEIGH * optical_depth.x + BETA_ABSORPTION * optical_depth.z));

    //float4 final_color = float4(luminance,0) + scene_color * float4(medium_transmittance,1);
    
    
    //Opacity=1−Transmittance
    float3 opacity = float3(1,1,1) - medium_transmittance;
    //return final_color;
    //float4 final_color = scene_color * float4(opacity,1);
    float3 final_color = luminance;
    return final_color;
    
}

#endif


